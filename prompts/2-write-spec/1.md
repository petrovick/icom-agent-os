Now that we've initiated and planned the details for a new spec, we will now proceed with drafting the specification document, following these instructions:

# Spec Writing

## Core Responsibilities

1. **Analyze Requirements**: Load and analyze requirements and visual assets thoroughly
2. **Search for Reusable Code**: Find reusable components and patterns in existing codebase
3. **Create Specification**: Write comprehensive specification document

## Workflow

### Step 1: Analyze Requirements and Context

Read and understand all inputs and THINK HARD:
```bash
# Read the requirements document
cat agent-os/specs/[current-spec]/planning/requirements.md

# Check for visual assets
ls -la agent-os/specs/[current-spec]/planning/visuals/ 2>/dev/null | grep -v "^total" | grep -v "^d"
```

Parse and analyze:
- User's feature description and goals
- Requirements gathered by spec-shaper
- Visual mockups or screenshots (if present)
- Any constraints or out-of-scope items mentioned

### Step 2: Search for Reusable Code

Before creating specifications, search the codebase for existing patterns and components that can be reused.

Based on the feature requirements, identify relevant keywords and search for:
- Similar features or functionality
- Existing UI components that match your needs
- Models, services, or controllers with related logic
- API patterns that could be extended
- Database structures that could be reused

Use appropriate search tools and commands for the project's technology stack to find:
- Components that can be reused or extended
- Patterns to follow from similar features
- Naming conventions used in the codebase
- Architecture patterns already established

Document your findings for use in the specification.

### Step 3: Create Core Specification

Write the main specification to `agent-os/specs/[current-spec]/spec.md`.

DO NOT write actual code in the spec.md document. Just describe the requirements clearly and concisely.

Keep it short and include only essential information for each section.

Follow this structure exactly when creating the content of `spec.md`:

```markdown
# Specification: [Feature Name]

## Goal
[1-2 sentences describing the core objective]

## User Stories
- As a [user type], I want to [action] so that [benefit]
- [repeat for up to 2 max additional user stories]

## Specific Requirements

**Specific requirement name**
- [Up to 8 CONCISE sub-bullet points to clarify specific sub-requirements, design or architectual decisions that go into this requirement, or the technical approach to take when implementing this requirement]

[repeat for up to a max of 10 specific requirements]

## Visual Design
[If mockups provided]

**`planning/visuals/[filename]`**
- [up to 8 CONCISE bullets describing specific UI elements found in this visual to address when building]

[repeat for each file in the `planning/visuals` folder]

## Existing Code to Leverage

**Code, component, or existing logic found**
- [up to 5 bullets that describe what this existing code does and how it should be re-used or replicated when building this spec]

[repeat for up to 5 existing code areas]

## Out of Scope
- [up to 10 concise descriptions of specific features that are out of scope and MUST NOT be built in this spec]
```

## Important Constraints

1. **Always search for reusable code** before specifying new components
2. **Reference visual assets** when available
3. **Do NOT write actual code** in the spec
4. **Keep each section short**, with clear, direct, skimmable specifications
5. **Do NOT deviate from the template above** and do not add additional sections


## Display confirmation and next step

Display the following message to the user:

```
The spec has been created at `agent-os/specs/[this-spec]/spec.md`.

Review it closely to ensure everything aligns with your vision and requirements.

Next step: Run the command, 2-create-tasks-list.md
```

## User Standards & Preferences Compliance

IMPORTANT: Ensure that the specification document's content is ALIGNED and DOES NOT CONFLICT with the user's preferences and standards as detailed in the following files:

@agent-os/standards//backend/api.md
@agent-os/standards//backend/migrations.md
@agent-os/standards//backend/models.md
@agent-os/standards//backend/queries.md
@agent-os/standards//backend/architecture.md
@agent-os/standards//frontend/accessibility.md
@agent-os/standards//frontend/components.md
@agent-os/standards//frontend/css.md
@agent-os/standards//frontend/responsive.md
@agent-os/standards//global/coding-style.md
@agent-os/standards//global/commenting.md
@agent-os/standards//global/conventions.md
@agent-os/standards//global/error-handling.md
@agent-os/standards//global/tech-stack.md
@agent-os/standards//global/validation.md
@agent-os/standards//testing/test-writing.md

--- CUSTOM INSTRUCTIONS FOR THIS SPEC ---

Spec name: "Pix Outgoing Stream Pull API"

Context:
- This spec is for the same product just planned in the product plan (Pix-like outgoing message pull API).
- Use the product mission/roadmap/tech-stack you just created as input context.

Key functional requirements:
- Endpoints:
  - GET /api/v1/out/{ispb}/stream/start
  - GET /api/v1/out/{ispb}/stream/{piPullNext}
- Behavior:
  - First call to /stream/start:
    - Returns up to 10 messages.
    - Returns a header `pi-pull-next` with a cursor/token.
  - Next calls to /stream/{piPullNext}:
    - Use the previous `pi-pull-next` value as the path parameter.
    - Return up to 10 messages and a new `pi-pull-next`.
  - Client keeps calling repeatedly, always using the last `pi-pull-next`.
- Response format:
  - Responses must be XML, not JSON.
  - Use boundary markers to separate up to 10 messages in a single response (similar to multipart/boundary).
- Concurrency:
  - Each PSP (identified by ISPB) can have up to 6 parallel threads polling those two URLs.
- Scale:
  - System must support **millions of requests per minute**.
  - High availability, horizontal scalability, and partitioning/sharding are important.

What this spec MUST focus on:
- High-level and detailed **architecture**, including:
  - Components and responsibilities (API layer, message storage, cursor management, security, observability, etc.).
  - Data and cursor model (including how `pi-pull-next` works conceptually).
  - Request/response flows for:
    - /stream/start
    - /stream/{piPullNext}
    - Parallel polling with up to 6 threads per PSP.
- Non-functional decisions:
  - Performance, scalability, reliability, fault tolerance.
  - Security and compliance.
  - Observability (logs, metrics, traces, alerts).

Very important constraints:
- DO NOT produce:
  - Any code (no TypeScript, no pseudo-code).
  - Any OpenAPI/Swagger YAML or JSON.
  - Any SQL, shell commands, or configuration snippets.
- The output should be a **textual spec document** only, describing architecture and behavior,
  ready to be used later as input to a tasks/backlog step (create-tasks).
