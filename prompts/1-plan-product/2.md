Main idea for the product (core concept and purpose)
- A high-throughput, Pix-like outgoing message pull API that allows participant institutions (identified by ISPB) to pull outbound Pix messages/transactions in a reliable, ordered, cursor-based way.
- It should mimic the SPI “pull of messages” behavior from Banco Central do Brasil, but as an internal/outgoing integration component inside our own architecture.

Key features (minimum 3, with short descriptions)
1) Cursor-based streaming with `pi-pull-next`
   - Every response returns a `pi-pull-next` token that represents the exact position in the outgoing message stream. Clients always use the last token for the next call, ensuring ordered, gap-free consumption.

2) XML batched responses with boundaries (up to 10 messages)
   - Responses are XML, not JSON, and use boundary markers (multipart-style or equivalent) to encapsulate and separate up to 10 messages per request, compatible with a Pix/SPI-like processing model.

3) High-volume, multi-tenant message stream per ISPB
   - The system supports millions of requests per minute and multiple institutions (via `{ispb}` in the URL), with isolation by ISPB, back-pressure, rate limiting, and clear handling of lagging consumers.

4) Controlled parallelism per PSP (up to 6 threads)
   - Each PSP (identified by ISPB) can open up to 6 parallel threads/clients polling those two URLs (`/stream/start` and `/stream/{piPullNext}`), and the system must guarantee correctness (ordering and no harmful gaps/duplicates) even under this controlled concurrency.

5) Observability and operational controls
   - Metrics, logs, and traces for message lag, throughput, error rates, and per-ISPB behavior, plus throttling/limits to prevent a single client from degrading the platform.

Target users and their use cases (minimum 1 segment)
- Primary segment: Financial institutions / PSPs (identified by ISPB) or internal services acting on their behalf.
  - Use case 1: Continuously pulling outgoing Pix messages that need to be processed, routed, or relayed to another domain (e.g., core banking, settlement, reconciliation).
  - Use case 2: Monitoring or replaying the outgoing message flow for operational and compliance purposes (within controlled, safe limits).
  - Use case 3: Integrating with external or legacy systems that expect a Pix/SPI-like pulling mechanism.

Will this product use your usual tech stack choices or does it deviate in any way?
- It should use my usual backend stack and patterns (modern, cloud-friendly, containerized services).
- The detailed tech stack (e.g., exact language, framework, database/streaming tech) can be proposed, but the product plan can assume:
  - A high-performance HTTP API service,
  - Backing message storage (stream + database or equivalent),
  - Standard observability stack.
- No major deviation from typical enterprise backend choices is required; the main complexity is in throughput, correctness, Pix-like behavior, and handling up to 6 concurrent threads per PSP, not in exotic technologies.
